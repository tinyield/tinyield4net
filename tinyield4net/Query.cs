using com.tinyield.Ops;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace com.tinyield
{
    /**
    * A sequence of elements supporting sequential operations.
    * Query operations are composed into a pipeline to perform
    * computation.
    */
    public class Query
    {
        /**
        * Returns a sequential ordered query whose elements
        * are the specified values in data parameter.
        */
        public static Query<U> Of<U>(params U[] data)
        {
            FromArray<U> op = new FromArray<U>(data);
            return new Query<U>(op.TryAdvance, op.Traverse);
        }

        /**
        * Returns a sequential ordered query with elements
        * from the provided IEnumerable data.
        */
        public static Query<U> FromEnumerable<U>(in IEnumerable<U> data)
        {
            FromEnumerable<U> op = new FromEnumerable<U>(data);
            return new Query<U>(op.TryAdvance, op.Traverse);
        }

        /**
        * Returns an infinite sequential ordered <c>Query</c> produced by iterative
        * application of a function <c>function</c> to an initial element <c>seed</c>,
        * producing a <c>Query</c> consisting of <c>seed</c>, <c>function(seed)</c>,
        * <c>function(function(seed))</c>, etc.
        *
        */
        public static Query<U> Iterate<U>(U seed, Func<U, U> function)
        {
            Iterate<U> op = new Iterate<U>(seed, function);
            return new Query<U>(op.TryAdvance, op.Traverse);
        }

        /**
        * Returns an infinite sequential unordered <c>Query</c>
        * where each element is generated by the provided Supplier.
        */
        public static Query<U> Generate<U>(Func<U> supplier)
        {
            Generate<U> op = new Generate<U>(supplier);
            return new Query<U>(op.TryAdvance, op.Traverse);
        }
    }

    /**
    * A sequence of elements supporting sequential operations.
    * Query operations are composed into a pipeline to perform
    * computation.
    */
    public class Query<T>
    {
        public readonly Advancer<T> adv;
        public readonly Traverser<T> trav;

        public Query(Advancer<T> adv, Traverser<T> trav)
        {
            this.adv = adv;
            this.trav = trav;
        }

        /**
        * Yields elements sequentially in the current thread,
        * until all elements have been processed or an
        * exception is thrown.
        */
        public void ForEach(Yield<T> yield)
        {
            trav(yield);
        }
        /**
        * Returns the first element of this query,
        * or throws an <see>InvalidOperationException</see> if this query is empty.
        */
        public T FindFirst()
        {
            T result = default;
            if (!adv(elem => result = elem))
            {
                throw new InvalidOperationException("The source sequence is empty");
            }
            return result;
        }

        /**
        * Returns any element of this query,
        * or throws an <see>InvalidOperationException</see> if this query is empty.
        */
        public T FindAny()
        {
            return FindFirst();
        }

        /**
        * Returns whether any elements of this query match the provided
        * predicate.  May not evaluate the predicate on all elements if not
        * necessary for determining the result.  If the query is empty then
        * <c>false</c> is returned and the predicate is not evaluated.
        */
        public bool AnyMatch(Predicate<T> predicate)
        {
            bool found = false;
            while (!found && adv(elem =>
            {
                if (predicate(elem))
                {
                    found = true;
                }
            })) { }
            return found;
        }

        /**
        * Returns whether no elements of this query match the provided
        * predicate.  May not evaluate the predicate on all elements if not
        * necessary for determining the result.  If the query is empty then
        * <c>true</c> is returned and the predicate is not evaluated.
        */
        public bool NoneMatch(Predicate<T> predicate)
        {
            return !AnyMatch(predicate);
        }

        /**
        * Returns whether all elements of this query match the provided
        * predicate.  May not evaluate the predicate on all elements if not
        * necessary for determining the result.  If the query is empty then
        * <c>true</c> is returned and the predicate is not evaluated.
        */
        public bool AllMatch(Predicate<T> predicate)
        {
            return !AnyMatch(item => !predicate(item));
        }

        /**
        * Returns the maximum element of this query according to the provided
        * <see>Comparison</see>.  This is a special case of a reduction.
        * throws an <see>InvalidOperationException</see> if the query is empty.
        */
        public T Max(Comparison<T> compare)
        {
            T max = default;
            bool found = false;
            trav(elem =>
            {
                if (!found)
                {
                    max = elem;
                    found = true;
                }
                else if (compare(max, elem) > 0)
                {
                    max = elem;
                }
            });
            if (!found)
            {
                throw new InvalidOperationException("The source sequence is empty");
            }
            return max;
        }

        /**
        * Returns the minimum element of this query according to the provided
        * <see>Comparison</see>.  This is a special case of a reduction.
        * throws an <see>InvalidOperationException</see> if the query is empty.
        */
        public T Min(Comparison<T> compare)
        {
            return Max((one, another) => compare(one, another) * -1);
        }

        /**
        * Returns a <c>Query</c> consisting of the elements of this <c>Query</c>,
        * sorted according to the provided <see>Comparison</see>.
        *
        * This is a stateful intermediate operation.
        */
        public Query<T> Sorted(Comparison<T> compare)
        {
            T[] src = ToArray();
            Array.Sort(src, compare);
            FromArray<T> sorted = new FromArray<T>(src);
            return new Query<T>(sorted.TryAdvance, sorted.Traverse);
        }

        /**
        * Returns a query consisting of the results of applying the given
        * <see>Func</see> to the elements of this query.
        */
        public Query<R> Map<R>(Func<T, R> mapper)
        {
            Mapping<T, R> map = new Mapping<T, R>(this, mapper);
            return new Query<R>(map.TryAdvance, map.Traverse);
        }

        /**
        * Returns a list containing the elements of this query.
        */
        public IList<T> ToList()
        {
            IList<T> data = new List<T>();
            trav(data.Add);
            return data;
        }

        /**
        * Returns a set containing the elements of this query.
        */
        public ISet<T> ToSet()
        {
            ISet<T> data = new HashSet<T>();
            trav(i => { data.Add(i); });
            return data;
        }

        /**
        * Returns an array containing the elements of this query.
        */
        public T[] ToArray()
        {
            return ToList().ToArray();
        }

        /**
        * Returns the count of elements in this query.
        */
        public long Count()
        {
            int c = 0;
            trav(i => c++);
            return c;
        }

        /**
        * Returns a query consisting of the elements of this query that match
        * the given predicate.
        */
        public Query<T> Filter(Predicate<T> predicate)
        {
            Filter<T> filter = new Filter<T>(this, predicate);
            return new Query<T>(filter.TryAdvance, filter.Traverse);
        }

        /**
        * Returns a query consisting of the remaining elements of this query
        * after discarding the first <c>n</c> elements of the query.
        */
        public Query<T> Skip(int n)
        {
            Skip<T> skip = new Skip<T>(this, n);
            return new Query<T>(skip.TryAdvance, skip.Traverse);
        }

        /**
        * Returns a <c>Query</c> consisting of the remaining elements of this query
        * after discarding the first sequence of elements that match the given Predicate.
        */
        public Query<T> DropWhile(Predicate<T> predicate)
        {
            DropWhile<T> dropWhile = new DropWhile<T>(this, predicate);
            return new Query<T>(dropWhile.TryAdvance, dropWhile.Traverse);
        }

        /**
        * Returns a query consisting of the elements of this query, truncated
        * to be no longer than <c>n</c> in length.
        */
        public Query<T> Limit(int n)
        {
            Limit<T> limit = new Limit<T>(this, n);
            return new Query<T>(limit.TryAdvance, limit.Traverse);
        }

        /**
        * Returns a query consisting of the longest prefix of elements taken from
        * this query that match the given predicate.
        */
        public Query<T> TakeWhile(Predicate<T> predicate)
        {
            TakeWhile<T> takeWhile = new TakeWhile<T>(this, predicate);
            return new Query<T>(takeWhile.TryAdvance, takeWhile.Traverse);
        }

        /**
        * Creates a concatenated <c>Query</c> in which the elements are
        * all the elements of this <c>Query</c> followed by all the
        * elements of the other <c>Query</c>.
        */
        public Query<T> Concat(Query<T> other)
        {
            Concat<T> contact = new Concat<T>(this, other);
            return new Query<T>(contact.TryAdvance, contact.Traverse);
        }

        /**
        * Returns a query consisting of the elements of this query, additionally
        * performing the provided action on each element as elements are consumed
        * from the resulting query.
        */
        public Query<T> Peek(Action<T> action)
        {
            Peek<T> peek = new Peek<T>(this, action);
            return new Query<T>(peek.TryAdvance, peek.Traverse);
        }

        /**
        * Returns a query consisting of the results of replacing each element of
        * this query with the contents of a mapped query produced by applying
        * the provided mapping function to each element.
        */
        public Query<R> FlatMap<R>(Func<T, Query<R>> mapper)
        {
            FlatMap<T, R> flatMap = new FlatMap<T, R>(this, mapper);
            return new Query<R>(flatMap.TryAdvance, flatMap.Traverse);
        }

        /**
        * Returns a query consisting of the distinct elements (according to
        * <see>IEqualityComparer<T>.Equals</see>) of this query.
        */
        public Query<T> Distinct()
        {
            Distinct<T> distinct = new Distinct<T>(this);
            return new Query<T>(distinct.TryAdvance, distinct.Traverse);
        }

        /**
        * Applies a specified function to the corresponding elements of two
        * sequences, producing a sequence of the results.
        */
        public Query<R> Zip<U, R>(Query<U> other, Func<T, U, R> zipper)
        {
            Zip<T, U, R> zip = new Zip<T, U, R>(this, other, zipper);
            return new Query<R>(zip.TryAdvance, zip.Traverse);
        }

        /**
        * The Then operator lets you encapsulate a piece of an operator
        * chain into a function.
        * The function <c>next</c> is applied to this query to produce a new
        * <see>Traverser</see> object that is encapsulated in the resulting query.
        */
        public Query<R> Then<R>(Func<Query<T>, Traverser<R>> next)
        {
            Advancer<R> unavailable = yld => throw new InvalidOperationException("Missing tryAdvance() implementation! Use the overloaded then() providing both Advancer and Traverser!");
            return new Query<R>(unavailable, next(this));
        }

        /**
        * The Then operator lets you encapsulate a piece of an operator
        * chain into a function.
        * The function <c>next</c> is applied to this query to produce a new
        * <see>Traverser</see> object that is encapsulated in the resulting query.
        * On the other hand, the <c>nextAdv</c> is applied to this query to produce a new
        * <see>Advancer</see> object that is encapsulated in the resulting query.
        */
        public Query<R> Then<R>(Func<Query<T>, Advancer<R>> nextAdv, Func<Query<T>, Traverser<R>> next)
        {
            return new Query<R>(nextAdv(this), next(this));
        }

        /**
        * Performs a mutable reduction operation on the elements of this <c>Query</c>.
        * A mutable reduction is one in which the reduced value is a mutable result container, such as a List,
        * and elements are incorporated by updating the state of the result rather than by replacing the result.
        */
        public R Collect<R>(Func<R> supplier, Func<R, T, R> accumulator)
        {
            R result = supplier();
            trav(elem => accumulator(result, elem));
            return result;
        }

        /**
        * Returns the concatenation of the input elements into a String, in encounter order.
        */
        public string Join()
        {
            return Map(elem => Convert.ToString(elem))
                .Collect(() => new StringBuilder(), (sb, elem) => sb.Append(elem))
                .ToString();
        }


        /**
        * Returns the resulting reduction of the elements of this <c>Query</c>,
        * if a reduction can be made, using the provided accumulator, otherwise throws
        * an <see>InvalidOperationException</see>.
        */
        public T Reduce(Func<T, T, T> accumulator)
        {
            T identity = default;
            if (adv(item => identity = item))
            {
                return Reduce(identity, accumulator);
            }
            else
            {
                throw new InvalidOperationException("The source sequence is empty");
            }
        }

        /**
        * Returns the resulting reduction of the elements of this <c>Query</c>,
        * using the provided identity and accumulator.
        */
        public T Reduce(T identity, Func<T, T, T> accumulator)
        {
            T result = identity;
            trav(item => result = accumulator(result, item));
            return result;
        }
    }
}
